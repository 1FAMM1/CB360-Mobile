<!DOCTYPE html>
<html lang="pt-PT">
<head>
  <meta charset="UTF-8">
 <meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="CB360 Mobile">
  <script>
  (function () {
    try {
      if (localStorage.getItem('sgo-theme') === 'dark') {
        // aplica cedo para n√£o piscar
        document.documentElement.classList.add('dark-mode');
      }
    } catch (e) {}
  })();
</script>

  <title>CB360_DOCUMENTOS</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet" />
  <style>
    /* ==================== 1. RESET E VARI√ÅVEIS ==================== */
    * {
        margin: 0; 
        padding: 0; 
        box-sizing: border-box; 
        -webkit-tap-highlight-color: transparent !important; 
        -webkit-touch-callout: none !important;
    }

    :root {
        --kb: 0px; 
        --footer-h: 60px; 
        --gap: 10px; 
        --safe: env(safe-area-inset-bottom, 0px);
        --selection-color: #bcd9ff;
        --header-h: 100px;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
        background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%); 
        min-height: 100vh; 
        height: 100dvh; 
        user-select: none;
        transition: background 0.3s ease; 
        display: flex; 
        flex-direction: column; 
        overflow: hidden;
    }

    /* ==================== 2. DARK MODE ==================== */
    .dark-mode {
        background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); 
        color: #fff; 
        --selection-color: #2b5278;
    }
    .dark-mode .main-content { background: transparent; }
    .dark-mode .msg-sender-name { color: #ffffff !important; }
    .dark-mode .contact { background: rgba(255, 255, 255, 0.08); color: #fff; border: 1px solid rgba(255, 255, 255, 0.15); }
    .dark-mode .message.self { background: #005c4b; color: #e9edef; }
    .dark-mode .message.self::after { border-left-color: #005c4b; }
    .dark-mode .message.other { background: #386580; color: #e9edef; }
    .dark-mode .message.other::after { border-right-color: #386580; }
    .dark-mode .chat-input-bar .input-wrapper { background: rgba(255, 255, 255, 0.15); }
    .dark-mode .chat-input-bar input { color: #fff; }
    .dark-mode .edit-bar, .dark-mode .reply-bar { background: rgba(45, 45, 45, 0.95); border-top: 1px solid #555; }
    .dark-mode .action-bar { background: #2d2d2d; border-bottom-color: #f9a825; }

    /* ==================== 3. ESTRUTURA PRINCIPAL ==================== */
    .header {
        background: linear-gradient(45deg, #d32f2f, #b71c1c); 
        color: white; padding: 20px 15px; text-align: center; 
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); border-bottom: 2px solid #c62828; 
        position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: var(--header-h);
    }

    .main-content {
        flex: 1; 
        display: flex; 
        flex-direction: column; 
        padding-top: var(--header-h); 
        overflow: hidden;
    }

    /* ==================== 4. LISTA DE CONTACTOS ==================== */
    #contact-list {
        display: flex; flex-direction: column; padding: 0 20px; flex: 1; 
        overflow-y: auto; -webkit-overflow-scrolling: touch; 
        padding-bottom: calc(var(--footer-h) + 20px + var(--kb) + var(--safe));
    }

    .contact {
        display: flex; align-items: center; gap: 10px; padding: 12px; border-radius: 12px; 
        background: rgba(0, 0, 0, 0.05); margin-bottom: 8px; cursor: pointer;
    }

    /* ==================== 5. CONTAINER DE MENSAGENS ==================== */
    .message-container {
        display: none; 
        flex-direction: column; 
        flex: 1;
        overflow-y: auto; 
        -webkit-overflow-scrolling: touch;
        padding: 15px;
        /* Medida Unificada: Footer + Input + Teclado + Safe Area */
        padding-bottom: calc(var(--footer-h) + 100px + var(--kb) + var(--safe));
        max-height: 100%;
        transition: padding-bottom 0.3s ease;
    }

    .message {
        max-width: 75%; padding: 10px; border-radius: 7.5px; margin-bottom: 8px; 
        position: relative; font-size: 14.5px; line-height: 1.5; 
        box-shadow: 0 1px 0.5px rgba(0,0,0,0.13); word-wrap: break-word;
    }
    .message.self { align-self: flex-end; background: #6b9e59; color: #fff; border-top-right-radius: 0; margin-right: 5px; }
    .message.self::after { content: ""; position: absolute; right: -10px; top: 0; border-left: 10px solid #6b9e59; border-bottom: 10px solid transparent; }
    .message.other { align-self: flex-start; background: #ddd; color: #000; border-top-left-radius: 0; margin-left: 5px; }
    .message.other::after { content: ""; position: absolute; left: -10px; top: 0; border-right: 10px solid #ddd; border-bottom: 10px solid transparent; }

    /* ==================== 6. BARRA DE INPUT ==================== */
    .chat-input-bar {
        position: fixed; 
        left: 0; right: 0; 
        bottom: calc(var(--footer-h) + var(--gap) + var(--kb) + var(--safe));
        display: none; 
        padding: 8px 10px; 
        z-index: 1001; 
        transition: bottom 0.12s ease;
        align-items: flex-end;
        gap: 8px;
        background: transparent;
    }

    .input-wrapper {
        display: flex; flex: 1; align-items: center; background: #ccc; 
        border-radius: 25px; padding: 5px 12px; min-height: 45px; transition: all 0.3s ease;
    }

    #chat-input {
        flex: 1; border: none; background: transparent; outline: none; 
        resize: none; padding: 10px 5px; font-size: 15px; max-height: 120px;
        color: inherit; font-family: inherit;
    }

    /* ==================== 7. BARRAS DE EDI√á√ÉO / RESPOSTA ==================== */
    .edit-bar, .reply-bar {
        position: fixed; 
        bottom: calc(var(--footer-h) + 65px + var(--kb) + var(--safe));
        left: 0; right: 0; 
        background: rgba(255, 255, 255, 0.95); 
        padding: 10px 15px; z-index: 1002; display: none;
        box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1); backdrop-filter: blur(10px);
    }

    /* ==================== 8. FOOTER ==================== */
    .footer {
        background: linear-gradient(45deg, #d32f2f, #b71c1c); color: white; 
        height: var(--footer-h); padding: 8px 15px; text-align: center; 
        position: fixed; bottom: 0; left: 0; right: 0; z-index: 1000;
        display: flex; align-items: center; justify-content: center;
        border-top: 2px solid #c62828;
    }

    /* ==================== 9. ESTADOS E ANIMA√á√ïES ==================== */
    .message.selected { background-color: var(--selection-color) !important; box-shadow: none !important; }
    
    .action-bar {
        position: fixed; top: var(--header-h); left: 0; right: 0; 
        background: #f0f0f0; border-bottom: 2px solid #d32f2f; 
        padding: 8px 15px; display: none; align-items: center; gap: 15px; z-index: 2000;
        transform: translateY(-100%); transition: transform 0.3s ease;
    }
    .action-bar.show { display: flex; transform: translateY(0); }

    #chat-send-btn {
        background: #00a884; color: white; border-radius: 50%; 
        width: 48px; height: 48px; flex-shrink: 0; border: none;
        display: flex; align-items: center; justify-content: center;
    }

    #camera-btn { 
        width: 32px; height: 32px; transition: width 0.3s, opacity 0.2s; 
        display: flex; align-items: center; justify-content: center;
    }

    /* ==================== 10. RESPONSIVIDADE ==================== */
    @media (max-width: 480px) {
        :root { --header-h: 70px; }
        .header h1 { font-size: 1.2em; }
        .message { max-width: 85%; }
        .chat-input-bar { padding: 5px 8px; }
    }
</style>
</head>
<body>
  <header class="header">
    <img id="corpLogo" class="header-logo" alt="Logo" src="https://rjkbodfqsvckvnhjwmhg.supabase.co/storage/v1/object/public/cb_logos/Mark_Logo_White.png">
    <h1>CHAT INTERNO</h1>
    <div class="header-subtitle">CHAT DE CONVERSA√á√ÉO INTERNA</div>
  </header> 
  <div class="action-bar" id="action-bar">
    <button class="action-bar-close" onclick="clearSelection()" title="Cancelar"><span class="material-icons">close</span></button> 
    <div class="action-bar-counter" id="action-counter"></div>
    <div class="action-bar-actions">
      <button class="action-btn" id="action-reply" onclick="actionReply()" title="Responder"><span class="material-icons">reply</span></button>
      <button class="action-btn" id="action-star" onclick="actionStar()" title="Favoritar"><span class="material-icons">star_border</span></button>
      <button class="action-btn" id="action-copy" onclick="actionCopy()" title="Copiar"><span class="material-icons">content_copy</span></button>
      <button class="action-btn" id="action-forward" onclick="actionForward()" title="Encaminhar"><span class="material-icons">forward</span></button>
      <button class="action-btn" id="action-delete" onclick="actionDelete()" title="Apagar"><span class="material-icons">delete</span></button>
      <button class="action-btn" id="action-edit" onclick="actionEdit()" title="Editar"><span class="material-icons">edit</span></button>
    </div>
  </div> 
  <div class="main-content">
    <div id="chat-header-group" style="display: contents;"> 
      <div id="back-header" class="back-header" onclick="goBackToMain()" style="display: none;">
        <span class="material-icons back-arrow">arrow_back</span>
        <span class="back-text" style="margin-left: 10px; font-weight: 500;">Voltar</span>
      </div>
      <div id="chat-id-info" class="chat-id-info" style="display: none;"></div>    
      <div id="pinned-message" class="pinned-banner" style="display: none;">
        <span class="material-icons" style="font-size: 18px;">push_pin</span>
        <div class="pinned-text" id="pinned-text-content">...</div>
      </div>
    </div>
    <div id="contact-title" class="contact-id-info">Contactos</div>
    <div id="contact-list"></div>
    <div id="messages" class="message-container"></div>
    <div id="typing-status" class="typing-indicator"></div>
  </div>
  <div class="chat-input-bar">
    <div class="input-wrapper">
      <button id="emoji-open-btn" type="button"><span class="material-icons">sentiment_satisfied_alt</span></button>
      <textarea id="chat-input" placeholder="Mensagem" autocomplete="off" rows="1"></textarea>
      <button id="attachment-btn" type="button"><span class="material-icons">attach_file</span></button>    
      <button id="camera-btn" type="button"><span class="material-icons">photo_camera</span></button>
    </div>
    <button id="chat-send-btn">
      <span class="material-icons" id="send-icon">mic</span>
    </button>
  </div>
  <div class="edit-bar" id="edit-bar">
    <div class="edit-bar-content">
      <span class="material-icons edit-icon">edit</span>
      <div class="edit-info">
        <div class="edit-label">Editar mensagem</div>
        <div class="edit-text-preview" id="edit-text-preview">...</div>
      </div>
      <button class="edit-cancel" onclick="cancelEdit()">‚úï</button>
    </div>
  </div>
  <div class="reply-bar" id="reply-bar">
    <div class="reply-bar-content">
      <span class="reply-icon">‚Ü©Ô∏è</span>
      <div class="reply-info">
        <div class="reply-to-name" id="reply-to-name">Nome</div>
        <div class="reply-to-text" id="reply-to-text">Mensagem...</div>
      </div>
      <button class="reply-cancel" onclick="cancelReply()">‚úï</button>
    </div>
  </div>
  <div id="reaction-menu" class="reaction-menu">
    <div class="emoji-scroll-container">
      <span class="reaction-emoji-container" onclick="handleReactionClick('üëç')">üëç</span>
      <span class="reaction-emoji-container" onclick="handleReactionClick('‚ù§Ô∏è')">‚ù§Ô∏è</span>
      <span class="reaction-emoji-container" onclick="handleReactionClick('üòÇ')">üòÇ</span>
      <span class="reaction-emoji-container" onclick="handleReactionClick('üòÆ')">üòÆ</span>
      <span class="reaction-emoji-container" onclick="handleReactionClick('üò¢')">üò¢</span>
      <span class="reaction-emoji-container" onclick="handleReactionClick('üôè')">üôè</span>
      <span class="reaction-emoji-container" onclick="handleReactionClick('üî•')">üî•</span>
      <span class="reaction-emoji-container" onclick="handleReactionClick('üëè')">üëè</span>
    </div>
    <div class="plus-button" onclick="openFullEmojiPicker()">
      <span class="material-icons">add</span>
    </div>
  </div>  
  <div id="modal-confirm" class="custom-confirm-overlay" style="display:none;">
    <div class="custom-confirm-card">
      <p class="confirm-text">Eliminar mensagem?</p>
      <div class="confirm-buttons-stack">
        <button onclick="resConfirm('todos')" class="btn-confirm-action">Eliminar para todos</button>
        <button onclick="resConfirm('mim')" class="btn-confirm-action">Eliminar s√≥ para mim</button>
        <button onclick="resConfirm('cancel')" class="btn-confirm-cancel">Cancelar</button>
      </div>
    </div>
  </div>
  <div class="footer">
    <div class="footer-content">
      <div class="powered-by"><strong>Powered by:</strong> F√°bio Martins | Sistemas de Informa√ß√£o - Grupo CB360</div>
      <div class="footer-year">¬© 2023-2025 - Sistema CB360 Mobile</div>
    </div>
  </div>
  <div id="full-emoji-picker-container">
    <emoji-picker locale="pt" class="light"></emoji-picker>
  </div>
  <input type="file" id="camera-file-input" accept="image/*" capture="environment" style="position:fixed; left:-9999px; top:0; width:1px; height:1px; opacity:0;"/>
  <div id="attach-modal" class="attach-modal">
    <div class="attach-card">
      <div class="attach-header">
        <span>Enviar Foto</span>
        <button id="attach-cancel" class="attach-x" type="button">‚úï</button>
      </div>
      <div class="attach-preview">
        <img id="attach-preview-img" src="" alt="preview" />
        <div id="attach-loading" class="attach-loading">A enviar...</div>
      </div>
      <div class="attach-footer">
        <input id="attach-caption" type="text" placeholder="Adicione uma legenda..." autocomplete="off" />
        <button id="attach-send" type="button">Enviar</button>
      </div>
    </div>
  </div>
  <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@1/index.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    (function () {
      function setVH() {
        document.documentElement.style.setProperty(
          '--vh',
          (window.innerHeight * 0.01) + 'px'
        );
      }
      window.addEventListener('resize', setVH);
      window.addEventListener('orientationchange', setVH);
      setVH();
    })();
  </script>
  <script>
    /* ===================== SUPABASE CONFIGURATION ====================== */
    const CONFIG = {
      SUPABASE_URL: 'https://rjkbodfqsvckvnhjwmhg.supabase.co',
      SUPABASE_ANON_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJqa2JvZGZxc3Zja3ZuaGp3bWhnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgxNjM3NjQsImV4cCI6MjA2MzczOTc2NH0.jX5OPZkz1JSSwrahCoFzqGYw8tYkgE8isbn12uP43-0',
      DEFAULT_CORP: '0805',
      DEFAULT_NINT: '205',
      STORAGE_BUCKET: 'cb_files',
      KEYBOARD_THRESHOLD: {OPEN_IOS: 80, OPEN_ANDROID: 120, CLOSE_IOS: 40, CLOSE_ANDROID: 60},
      AVATAR_COLORS: {'A': '#f44336', 'B': '#e91e63', 'C': '#9c27b0', 'D': '#673ab7', 'E': '#3f51b5', 'F': '#2196f3', 'G': '#03a9f4', 'H': '#00bcd4', 
                      'I': '#009688', 'J': '#4caf50', 'K': '#8bc34a', 'L': '#cddc39', 'M': '#ffeb3b', 'N': '#ffc107', 'O': '#ff9800', 'P': '#ff5722',
                      'Q': '#795548', 'R': '#9e9e9e', 'S': '#60727b', 'T': '#333333', 'U': '#ff4081', 'V': '#7c4dff', 'W': '#536dfe', 'X': '#448aff', 
                      'Y': '#00e676', 'Z': '#cfd8dc'}};
    /* ======================== GLOBAL CONSTANTS ========================= */
    const AppState = {
      currentChat: 'null',
      currentChatName: '',
      lastDateLabel: '',
      totalTeam: 0,
      currentReplyToMessage: null,
      currentEditingMessage: null,
      selectedMessages: [],
      messagesToForward: [],
      reactionTargetId: null,
      mediaRecorder: null,
      audioChunks: [],
      isRecording: false,
      recordTimeout: null,
      confirmResolver: null,
      currentUserNint: String(localStorage.getItem("currentCorpNint") || CONFIG.DEFAULT_NINT),  
      reset() {
        this.selectedMessages = [];
        this.currentReplyToMessage = null;
        this.currentEditingMessage = null;
        this.reactionTargetId = null;
      }
    };
    /* ====================== HELPERS AND UTILITIES ====================== */
    const Helpers = {
      getCorpNr: () => localStorage.getItem("currentCorpOperNr") || CONFIG.DEFAULT_CORP,  
      getUserNint: () => localStorage.getItem("currentCorpNint") || CONFIG.DEFAULT_NINT,  
      isChatActive: (chat = AppState.currentChat) => chat && chat !== 'null',  
      getMessageElement: (id) => document.querySelector(`[data-message-id="${id}"]`),  
      getSupabaseHeaders: (options = {}) => {
        const headers = {
          'apikey': CONFIG.SUPABASE_ANON_KEY,
          'Authorization': `Bearer ${CONFIG.SUPABASE_ANON_KEY}`,
          'Content-Type': 'application/json',
          'x-my-corpo': Helpers.getCorpNr(),
          'x-my-nint': Helpers.getUserNint()
        };
        if (options.returnRepresentation) headers['Prefer'] = 'return=representation';
        return headers;
      },  
      escapeHtml: (text) => {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      },  
      formatTime: (date) => {
        return new Date(date).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      },  
      getDateLabel: (date) => {
        const today = new Date();
        const yesterday = new Date();
        yesterday.setDate(today.getDate() - 1);
        if (date.toDateString() === today.toDateString()) return "Hoje";
        if (date.toDateString() === yesterday.toDateString()) return "Ontem";
        return date.toLocaleDateString('pt-PT', {day: '2-digit', month: '2-digit', year: 'numeric'});
      }
    };
    /* ========================== DOM HELPERS ============================ */
    const DOM = {
      messages: () => document.getElementById("messages"),
      contactList: () => document.getElementById("contact-list"),
      contactTitle: () => document.getElementById("contact-title"),
      chatIdInfo: () => document.getElementById("chat-id-info"),
      backHeader: () => document.getElementById("back-header"),
      pinnedMessage: () => document.getElementById("pinned-message"),
      inputBar: () => document.querySelector(".chat-input-bar"),
      chatInput: () => document.getElementById("chat-input"),
      typingStatus: () => document.getElementById("typing-status"),
      actionBar: () => document.getElementById("action-bar"),
      reactionMenu: () => document.getElementById("reaction-menu"),
      emojiContainer: () => document.getElementById("full-emoji-picker-container")
    };
    /* ===================== SUPABASE INITIALIZATION ===================== */
    const supabaseClient = supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);
    /* ================== VIEWPORT MANAGEMENT (PWA FIX) ================== */
    (function initViewport() {
      function setVH() {
        document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
      }
      window.addEventListener('resize', setVH);
      window.addEventListener('orientationchange', setVH);
      setVH();
    })();
    /* ======================= IMAGE MENU HANDLER ======================== */
    const ImageHandler = {
      init() {
        document.addEventListener('click', (e) => {
          const img = e.target.closest('.chat-img');
          if (!img) return;
          e.preventDefault();
          e.stopPropagation();
          window.location.href = img.dataset.url;
        });        
        document.addEventListener('contextmenu', (e) => {
          if (e.target.closest('.chat-img')) e.preventDefault();
        });
      }
    };
   /* ======================= CHAT INPUT HANDLER ======================== */
const ChatInputHandler = {
  init() {
    const chatInput = DOM.chatInput();
    if (!chatInput) return;

    chatInput.addEventListener('input', () => {
      // 1. Ajuste de altura (o que j√° tinha)
      chatInput.style.height = 'auto';
      chatInput.style.height = (chatInput.scrollHeight) + 'px';
      
      // 2. Scroll para acompanhar o crescimento do input
      DOM.messages()?.scrollTo(0, DOM.messages().scrollHeight);

      // 3. AGORA: Troca instant√¢nea do bot√£o (C√¢mara vs Enviar)
      this.toggleSendButton();
    });
  },

  toggleSendButton() {
    const chatInput = DOM.chatInput();
    const cameraBtn = document.getElementById('camera-btn');
    const sendBtn = document.getElementById('send-btn');
    
    if (!chatInput || !cameraBtn || !sendBtn) return;

    // Se o input tiver qualquer texto (removendo espa√ßos vazios)
    if (chatInput.value.trim().length > 0) {
      cameraBtn.style.display = 'none';
      sendBtn.style.display = 'flex';
    } else {
      cameraBtn.style.display = 'flex';
      sendBtn.style.display = 'none';
    }
  }
};
    /* ========================= LAYOUT MANAGER ========================== */
    const LayoutManager = {
      resetLayout() {
        const emojiContainer = DOM.emojiContainer();
        const inputBar = DOM.inputBar();
        const messageContainer = DOM.messages();        
        emojiContainer.style.display = 'none';
        inputBar.style.removeProperty('bottom');
        messageContainer.style.removeProperty('margin-bottom');        
        setTimeout(() => ScrollManager.toBottom(), 100);
      },      
      scrollToBottom() {
        const messagesEl = DOM.messages();
        if (messagesEl && messagesEl.style.display !== 'none') {
          setTimeout(() => {
            messagesEl.scrollTo({
              top: messagesEl.scrollHeight,
              behavior: 'smooth'
            });
          }, 50);
        }
      }
    };
    /* ========================= SCROLL MANAGER ========================== */
    const ScrollManager = {
      toBottom() {
        LayoutManager.scrollToBottom();
      },  
      toMessage(messageId) {
        const msgElement = Helpers.getMessageElement(messageId);
        if (msgElement) {
          msgElement.scrollIntoView({behavior: 'smooth', block: 'center'});
          msgElement.style.background = 'rgba(188, 217, 255, 0.5)';
          setTimeout(() => { msgElement.style.background = ''; }, 1500);
        }
      }
    };
    /* ======================== TYPING INDICATOR ========================= */
    const TypingIndicator = {
  init() {
    const inputMensage = DOM.chatInput();
    const inputBar = DOM.inputBar();
    const iconBtn = document.getElementById('send-icon');
    const emojiBtn = document.getElementById('emoji-open-btn');
    const emojiContainer = DOM.emojiContainer();
    const picker = document.querySelector('emoji-picker');
    const messageContainer = DOM.messages();    
    inputMensage.addEventListener('input', function() {
      const hasText = this.value.trim().length > 0;
      const novoIcone = hasText ? 'send' : 'mic';      
      if (iconBtn.textContent !== novoIcone) {
        iconBtn.style.transform = 'rotate(180deg) scale(0)';
        iconBtn.style.opacity = '0';        
        setTimeout(() => {
          iconBtn.textContent = novoIcone;
          iconBtn.style.transform = 'rotate(0deg) scale(1)';
          iconBtn.style.opacity = '1';          
          if (hasText) {
            inputBar.classList.add('typing');
          } else {
            inputBar.classList.remove('typing');
          }
        }, 150);
      }
    });    
    emojiBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (emojiContainer.style.display === 'block') {
        LayoutManager.resetLayout();
        inputMensage.focus();
      } else {
        inputMensage.blur();
        setTimeout(() => {
          emojiContainer.style.display = 'block';
          // Limpa o modo de rea√ß√£o (este picker √© para escrever)
          delete emojiContainer.dataset.mode;
          inputBar.style.bottom = '305px';
          messageContainer.style.marginBottom = '325px';          
          let scrollAcompanha = setInterval(() => {
            messageContainer.scrollTop = messageContainer.scrollHeight;
          }, 10);
          setTimeout(() => clearInterval(scrollAcompanha), 400);
        }, 50);
      }
    });    
    picker.addEventListener('emoji-click', event => {
      // S√≥ escreve no input se N√ÉO estiver em modo de rea√ß√£o
      if (emojiContainer.dataset.mode !== 'reaction') {
        const emoji = event.detail.unicode;
        const inicio = inputMensage.selectionStart;
        const fim = inputMensage.selectionEnd;      
        inputMensage.value = inputMensage.value.substring(0, inicio) + emoji + inputMensage.value.substring(fim);
        const novaPosicao = inicio + emoji.length;
        inputMensage.setSelectionRange(novaPosicao, novaPosicao);
        inputMensage.dispatchEvent(new Event('input'));
      }
    });    
    inputMensage.addEventListener('focus', () => LayoutManager.resetLayout());
    messageContainer.addEventListener('click', () => {
      if (emojiContainer.style.display === 'block') LayoutManager.resetLayout();
    });
  }
};
    /* ========================= AUDIO RECORDING ========================= */
    const AudioRecorder = {
      async start(e) {
        const iconBtn = document.getElementById('send-icon');
        if (iconBtn.textContent !== 'mic') return;
        if (!Helpers.isChatActive()) return;    
        AppState.recordTimeout = setTimeout(async () => {
          try {
            const permission = await navigator.permissions.query({ name: 'microphone' });
            if (permission.state === 'denied') {
              alert('‚ö†Ô∏è Acesso ao microfone bloqueado!\n\nPor favor, ativa nas defini√ß√µes do browser.');
              return;
            }        
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            AppState.mediaRecorder = new MediaRecorder(stream);
            AppState.audioChunks = [];        
            AppState.mediaRecorder.ondataavailable = e => AppState.audioChunks.push(e.data);
            AppState.mediaRecorder.onstop = async () => {
              const audioBlob = new Blob(AppState.audioChunks, { type: 'audio/webm' });
              if (audioBlob.size > 2000) {
                await this.upload(audioBlob);
              }
              stream.getTracks().forEach(t => t.stop());
            };        
            AppState.mediaRecorder.start();
            AppState.isRecording = true;
            iconBtn.classList.add("recording-pulse");
            DOM.chatInput().placeholder = "üî¥ A gravar... solte para enviar";
            DOM.inputBar().style.backgroundColor = "#fff5f5";
          } catch (err) {
            console.error("Erro ao aceder ao microfone:", err);
            this.handleError(err);
          }
        }, 250);
      },  
      stop() {
        clearTimeout(AppState.recordTimeout);
        const iconBtn = document.getElementById('send-icon');
        const inputBar = DOM.inputBar();
        const chatInput = DOM.chatInput();    
        if (AppState.isRecording) {
          AppState.mediaRecorder.stop();
          AppState.isRecording = false;
          iconBtn.classList.remove("recording-pulse");
          chatInput.placeholder = "Mensagem";
          inputBar.style.backgroundColor = "";
        } else {
          chatInput.placeholder = "Mensagem";
          inputBar.style.backgroundColor = "";
        }
      },  
      async upload(blob) {
        const fileName = `audio_${Date.now()}.webm`;
        const filePath = `${AppState.currentChat}/${fileName}`;    
        try {
          const { data, error } = await supabaseClient.storage
            .from(CONFIG.STORAGE_BUCKET)
            .upload(filePath, blob);      
          if (error) throw error;      
          const { data: { publicUrl } } = supabaseClient.storage
            .from(CONFIG.STORAGE_BUCKET)
            .getPublicUrl(filePath);      
          await MessageSender.send("Enviou um √°udio", publicUrl);
        } catch (err) {
          console.error("Erro:", err.message);
        }
      },  
      handleError(err) {
        if (err.name === 'NotAllowedError') {
          alert('‚ö†Ô∏è Permiss√£o negada!\n\nClica no cadeado ao lado do URL e permite o acesso ao microfone.');
        } else if (err.name === 'NotFoundError') {
          alert('‚ö†Ô∏è Microfone n√£o encontrado!\n\nVerifica se tens um microfone ligado.');
        } else {
          alert('‚ùå Erro ao aceder ao microfone: ' + err.message);
        }
      },  
      init() {
        const iconBtn = document.getElementById('send-icon');    
        iconBtn.addEventListener('mousedown', () => this.start());
        window.addEventListener('mouseup', () => this.stop());    
        iconBtn.addEventListener('touchstart', (e) => {
          if (iconBtn.textContent === 'mic') e.preventDefault();
          this.start();
        }, {passive: false});    
        window.addEventListener('touchend', () => this.stop());
      }
    };
    /* ===================== CAMERA & IMAGE HANDLER ====================== */
    const CameraHandler = {
      pendingFile: null,
      previewUrl: null,  
      init() {
        const cameraBtn = document.getElementById("camera-btn");
        const cameraInput = document.getElementById("camera-file-input");
        const attachModal = document.getElementById("attach-modal");
        const attachImg = document.getElementById("attach-preview-img");
        const attachCaption = document.getElementById("attach-caption");
        const attachSend = document.getElementById("attach-send");
        const attachCancel = document.getElementById("attach-cancel");
        const attachLoading = document.getElementById("attach-loading");    
        cameraBtn.addEventListener("click", (e) => {
          e.preventDefault();
          if (!Helpers.isChatActive()) return;
          cameraInput.value = "";
          cameraInput.click();
        });    
        cameraInput.addEventListener("change", () => {
          const file = cameraInput.files?.[0];
          if (!file) return;      
          this.pendingFile = file;
          if (this.previewUrl) URL.revokeObjectURL(this.previewUrl);      
          this.previewUrl = URL.createObjectURL(file);
          attachImg.src = this.previewUrl;
          attachCaption.value = "";
          attachModal.style.display = "flex";      
          setTimeout(() => attachCaption.focus(), 150);
        });    
        attachCancel.addEventListener("click", () => this.closeModal());    
        attachSend.addEventListener("click", async () => {
          if (!this.pendingFile) return;      
          const caption = (attachCaption.value || "").trim();      
          try {
            attachLoading.style.display = "block";
            attachSend.disabled = true;        
            const publicUrl = await this.uploadImage(this.pendingFile);
            await this.sendImageMessage(publicUrl, this.pendingFile.name || `foto_${Date.now()}.jpg`, caption);        
            this.closeModal();
          } catch (err) {
            console.error("Erro ao enviar foto:", err);
            alert("N√£o foi poss√≠vel enviar a foto.");
            attachLoading.style.display = "none";
            attachSend.disabled = false;
          }
        });
      },  
      closeModal() {
        const attachModal = document.getElementById("attach-modal");
        const attachLoading = document.getElementById("attach-loading");
        const attachSend = document.getElementById("attach-send");
        const cameraInput = document.getElementById("camera-file-input");    
        attachModal.style.display = "none";
        attachLoading.style.display = "none";
        attachSend.disabled = false;    
        if (this.previewUrl) {
          URL.revokeObjectURL(this.previewUrl);
          this.previewUrl = null;
        }    
        this.pendingFile = null;
        cameraInput.value = "";
      },  
      async uploadImage(file) {
        if (file.type && !file.type.startsWith("image/")) {
          throw new Error("Ficheiro n√£o √© imagem.");
        }    
        const ext = (file.name?.split(".").pop() || "jpg").toLowerCase();
        const fileName = `photo_${Date.now()}.${ext}`;
        const filePath = `${AppState.currentChat}/${fileName}`;    
        const { error } = await supabaseClient.storage
          .from(CONFIG.STORAGE_BUCKET)
          .upload(filePath, file, { contentType: file.type || "image/jpeg" });    
        if (error) throw error;    
        const { data: { publicUrl } } = supabaseClient.storage
          .from(CONFIG.STORAGE_BUCKET)
          .getPublicUrl(filePath);    
        if (!publicUrl) throw new Error("Sem URL p√∫blico.");    
        return publicUrl;
      },  
      async sendImageMessage(imageUrl, fileName, caption = "") {
        const senderName = await UserManager.fetchName();    
        const payload = {n_int: AppState.currentUserNint, recipient_nint: String(AppState.currentChat), corp_oper_nr: Helpers.getCorpNr(), abv_name: senderName, message_type: "image",
                         file_url: imageUrl, file_name: fileName, message: caption};    
        const { error } = await supabaseClient
          .from("chat_messages")
          .insert([payload]);    
        if (error) throw error;
      }
    };
    /* ========================== USER MANAGER =========================== */
    const UserManager = {
      async fetchName() {
        try {
          const { data } = await supabaseClient
            .from('reg_elems')
            .select('abv_name')
            .eq('n_int', AppState.currentUserNint)
            .maybeSingle();      
          return (data && data.abv_name) ? data.abv_name : "Utilizador";
        } catch {
          return "Utilizador";
        }
      }
    };
    /* ======================== CORPORATION DATA ========================= */
    const CorpManager = {
      async loadInfo() {
        const corpOperNr = Helpers.getCorpNr();
        const logoEl = document.getElementById("corpLogo");    
        try {
          const response = await fetch(
            `${CONFIG.SUPABASE_URL}/rest/v1/corporation_data?select=corporation,corp_oper_nr,logo_url&corp_oper_nr=eq.${corpOperNr}`,
            {headers: Helpers.getSupabaseHeaders()
            }
          );      
          const data = await response.json();
          if (data && data.length > 0 && logoEl && data[0].logo_url) {
            logoEl.src = data[0].logo_url.trim();
          }
        } catch (err) {
          console.error('Erro no loadCorpInfo:', err);
        }
      }
    };
    /* ========================== THEME MANAGER ========================== */
    const ThemeManager = {
  load() {
    const isDark = localStorage.getItem('sgo-theme') === 'dark';
    document.documentElement.classList.toggle('dark-mode', isDark);
    document.body.classList.toggle('dark-mode', isDark); // opcional, mas ajuda se houver CSS dependente do body
  }
};
    /* ========================= CONTACT MANAGER ========================= */
    const ContactManager = {
      async load() {
        const corpOperNr = Helpers.getCorpNr();        
        const { data: users, error } = await supabaseClient
          .from('reg_elems')
          .select('n_int, abv_name, photo_url, elem_state')
          .eq('corp_oper_nr', corpOperNr)
          .eq('elem_state', true)
          .order('n_int', {ascending: true});        
        if (error) return console.error(error);        
        AppState.totalTeam = users.length + 1;        
        const listEl = DOM.contactList();
        listEl.innerHTML = '';
        this.addGeralContact(listEl);
        users.forEach(user => {
          if (String(user.n_int) === AppState.currentUserNint) return;
          this.addContact(listEl, user);
        });
      },      
      addGeralContact(listEl) {
        const draftGeral = localStorage.getItem("draft_geral");
        const subTextGeral = draftGeral 
          ? `<div class="draft-preview">Rascunho: ${draftGeral}</div>` 
          : `<div class="nint">Broadcast</div>`;        
        const geral = document.createElement("div");
        geral.className = "contact";
        geral.dataset.nint = 'geral';
        geral.onclick = () => ChatManager.open('geral', 'Chat Geral');        
        geral.innerHTML = `
          <div class="contact-avatar" style="background-color: #333;">G</div>
          <div class="contact-info">
            <div class="name">Chat Geral</div>
            ${subTextGeral}
          </div>`;        
        listEl.appendChild(geral);
      },      
      addContact(listEl, user) {
        const contactId = String(user.n_int);
        const firstLetter = user.abv_name.charAt(0).toUpperCase();
        const avatarColor = CONFIG.AVATAR_COLORS[firstLetter] || '#d32f2f';        
        const savedDraft = localStorage.getItem(`draft_${contactId}`);
        const subText = savedDraft 
          ? `<div class="draft-preview">Rascunho: ${savedDraft}</div>` 
          : `<div class="nint">ID: ${user.n_int}</div>`;        
        const div = document.createElement("div");
        div.className = "contact";
        div.setAttribute('data-nint', contactId);
        div.onclick = () => ChatManager.open(user.n_int, user.abv_name);        
        const avatarContent = user.photo_url 
          ? `<img src="${user.photo_url}">` 
          : firstLetter;        
        div.innerHTML = `
          <div class="contact-avatar" style="background-color: ${user.photo_url ? 'transparent' : avatarColor};">
            ${avatarContent}
            <div class="status-dot"></div>
          </div>
          <div class="contact-info">
            <div class="name">${user.abv_name}</div>
            ${subText}
          </div>`;
        
        listEl.appendChild(div);
      }
    };
    /* ========================== BADGE MANAGER ========================== */
    const BadgeManager = {
      async update() {
        const currentCorp = Helpers.getCorpNr();
        const { count: totalGeral } = await supabaseClient
          .from('chat_messages')
          .select('*', { count: 'exact', head: true })
          .eq('recipient_nint', 'geral')
          .eq('corp_oper_nr', currentCorp)
          .neq('n_int', AppState.currentUserNint);        
        const { count: lidasGeral } = await supabaseClient
          .from('chat_message_reads')
          .select('*', { count: 'exact', head: true })
          .eq('n_int', AppState.currentUserNint)
          .eq('corp_oper_nr', currentCorp);        
        const unreadGeral = Math.max(0, (totalGeral || 0) - (lidasGeral || 0));
        const { data: privData } = await supabaseClient
          .from('chat_messages')
          .select('n_int')
          .eq('recipient_nint', AppState.currentUserNint)
          .eq('corp_oper_nr', currentCorp)
          .is('read_at', null);        
        const privCounts = {};
        if (privData) {
          privData.forEach(msg => {
            privCounts[msg.n_int] = (privCounts[msg.n_int] || 0) + 1;
          });
        }
        document.querySelectorAll('.contact').forEach(contactEl => {
          const nint = contactEl.getAttribute('data-nint');
          let finalCount = (nint === 'geral') ? unreadGeral : (privCounts[nint] || 0);
          let badge = contactEl.querySelector('.unread-badge');          
          if (finalCount > 0) {
            if (!badge) {
              badge = document.createElement('div');
              badge.className = 'unread-badge';
              contactEl.appendChild(badge);
            }
            badge.textContent = finalCount > 99 ? '99+' : finalCount;
          } else {
            if (badge) badge.remove();
          }
        });
      }
    };
    /* ========================== CHAT MANAGER =========================== */
    const ChatManager = {
      async open(n_int, name) {
        const messagesEl = DOM.messages();
        const contactListEl = DOM.contactList();
        const contactTitle = DOM.contactTitle();
        const chatIdInfo = DOM.chatIdInfo();
        const backBtn = DOM.backHeader();
        const pinnedEl = DOM.pinnedMessage();
        const inputBar = DOM.inputBar();
        const typingStatusEl = DOM.typingStatus();
        const inputMensage = DOM.chatInput();    
        messagesEl.innerHTML = '';
        if (AppState.messagesToForward.length > 0) {
          await this.forwardMessages(n_int);
        }    
        AppState.currentChat = String(n_int);
        AppState.currentChatName = name;
        if (AppState.currentChat === 'geral') {
          await ReadManager.markGeralAsRead();
          BadgeManager.update();
        } else {
          const badge = document.querySelector(`.contact[data-nint="${n_int}"] .unread-badge`);
          if (badge) badge.remove();
          ReadManager.sendReceipt(AppState.currentChat);
        }
        contactListEl.style.display = 'none';
        contactTitle.style.display = 'none';
        messagesEl.style.display = 'flex';
        backBtn.style.display = 'flex';
        chatIdInfo.style.display = 'block';
        typingStatusEl.style.display = 'none';
        inputBar.style.display = 'flex';    
        chatIdInfo.textContent = `A conversar com: ${name}`;
        if (AppState.currentChat === 'geral') {
          pinnedEl.style.display = 'flex';
          document.getElementById("pinned-text-content").textContent = 
            "ATEN√á√ÉO! Este chat √© supervisionado por IA. Qualquer mensagem que viole normas √©ticas ser√° imediatamente bloqueada.";
        } else {
          pinnedEl.style.display = 'none';
        }
        const savedDraft = localStorage.getItem(`draft_${AppState.currentChat}`);
        if (savedDraft) {
          inputMensage.value = savedDraft;
          inputMensage.dispatchEvent(new Event('input'));
        } else {
          inputMensage.value = "";
          inputMensage.dispatchEvent(new Event('input'));
        }    
        await MessageManager.load(AppState.currentChat);
      },  
      async forwardMessages(n_int) {
        const currentCorp = Helpers.getCorpNr();
        const senderName = await UserManager.fetchName();    
        for (const msg of AppState.messagesToForward) {
          const payload = {n_int: AppState.currentUserNint, recipient_nint: String(n_int), corp_oper_nr: currentCorp, abv_name: senderName, message: msg.message || "", message_type: msg.message_type || "text",
                           file_url: msg.file_url || null, file_name: msg.file_name || null, is_forwarded: true};      
          const { error } = await supabaseClient.from('chat_messages').insert([payload]);
          if (error) console.error("Erro ao encaminhar mensagem:", error);
        }    
        AppState.messagesToForward = [];
        await new Promise(resolve => setTimeout(resolve, 150));
      },  
      goBack() {
        const text = DOM.chatInput().value.trim();    
        if (text !== "" && Helpers.isChatActive()) {
          localStorage.setItem(`draft_${AppState.currentChat}`, text);
        } else if (Helpers.isChatActive()) {
          localStorage.removeItem(`draft_${AppState.currentChat}`);
        }    
        LayoutManager.resetLayout();
        DOM.chatInput().value = "";
        DOM.chatInput().dispatchEvent(new Event('input'));    
        DOM.pinnedMessage().style.display = 'none';
        DOM.messages().style.display = 'none';
        DOM.backHeader().style.display = 'none';
        DOM.chatIdInfo().style.display = 'none';
        DOM.typingStatus().style.display = 'none';
        document.getElementById("reply-bar").style.display = 'none';
        DOM.inputBar().style.display = 'none';    
        DOM.contactList().style.display = 'flex';
        DOM.contactTitle().style.display = 'block';    
        AppState.currentChat = 'null';
        ContactManager.load();
      }
    };
    /* ========================= MESSAGE MANAGER ========================= */
    const MessageManager = {
      async load(chat = AppState.currentChat) {
        const currentCorp = Helpers.getCorpNr();
        const messagesEl = DOM.messages();
        const chatRef = chat || 'geral';    
        messagesEl.innerHTML = '';
        AppState.lastDateLabel = "";    
        let query = supabaseClient
          .from('chat_messages')
          .select('*, chat_message_reads(count), reply_to_message:reply_to_message_id(id, message, abv_name)')
          .eq('corp_oper_nr', currentCorp);    
        if (chatRef === 'geral') {
          query = query.eq('recipient_nint', 'geral');
        } else {
          query = query.or(`and(n_int.eq.${AppState.currentUserNint},recipient_nint.eq.${chatRef}),and(n_int.eq.${chatRef},recipient_nint.eq.${AppState.currentUserNint})`);
        }    
        try {
          const { data: msgs, error } = await query.order('created_at', {ascending: true});      
          if (AppState.currentChat !== chatRef) return;
          if (error) return console.error(error);      
          if (!msgs || msgs.length === 0) {
            this.showEmptyPlaceholder();
          } else {
            msgs.forEach(msg => this.addToDOM(msg, chatRef));
            ScrollManager.toBottom();
          }
        } catch (err) {
          console.error(err);
        }
      },  
      showEmptyPlaceholder() {
        const messagesEl = DOM.messages();
        const emptyMsg = document.createElement("div");
        emptyMsg.className = "empty-chat-placeholder";
        emptyMsg.innerHTML = `
          <div style="text-align: center; width: 100%; padding: 20px;">
            <span class="material-icons" style="font-size: 48px; display: block; margin: 0 auto 10px auto; opacity: 0.3;">chat_bubble_outline</span>
            <span style="opacity: 0.3;">Ainda n√£o iniciou nenhuma conversa com<br><strong>${AppState.currentChatName || 'este contacto'}</strong></span>
          </div>
        `;
        messagesEl.appendChild(emptyMsg);
      },  
      addToDOM(msg, chatRef) {
        if (!Helpers.isChatActive() || AppState.currentChat !== String(chatRef)) return;    
        const messagesEl = DOM.messages();
        if (!messagesEl) return;
        const msgDate = new Date(msg.created_at);
        const dateLabel = Helpers.getDateLabel(msgDate);    
        if (dateLabel !== AppState.lastDateLabel) {
          const divider = document.createElement("div");
          divider.className = "date-divider";
          divider.innerHTML = `<span>${dateLabel}</span>`;
          messagesEl.appendChild(divider);
          AppState.lastDateLabel = dateLabel;
        }    
        const emptyMsg = messagesEl.querySelector(".empty-chat-placeholder");
        if (emptyMsg) emptyMsg.remove();    
        const div = this.createMessageElement(msg, chatRef);
        messagesEl.appendChild(div);    
        if (messagesEl.style.display !== 'none') {
          ScrollManager.toBottom();
        }
      },  
      createMessageElement(msg, chatRef) {
        const time = Helpers.formatTime(msg.edited_at || msg.created_at);
        const isMe = String(msg.n_int) === AppState.currentUserNint;
        const isDeleted = msg.deleted_at !== null && msg.deleted_at !== undefined;    
        const div = document.createElement("div");
        div.className = "message " + (isMe ? "self" : "other");
        div.dataset.messageId = msg.id;
        div.dataset.messageText = msg.message;
        div.dataset.senderName = msg.abv_name;
        div.dataset.senderNint = msg.n_int;    
        if (isDeleted) div.classList.add('deleted');
        if (msg.is_forwarded) div.classList.add('is-forwarded');    
        const nameHTML = (chatRef === 'geral' && !isMe) 
          ? `<div class="msg-sender-name">${msg.abv_name}</div>` 
          : "";    
        const replyPreviewHTML = this.buildReplyPreview(msg);
        const checkHTML = this.buildStatusChecks(msg, isMe, chatRef);
        const reactionsHTML = ReactionManager.render(msg.reactions, msg.id);
        const starIcon = (msg.starred_by && msg.starred_by.includes(AppState.currentUserNint))
          ? '<span class="star-icon" style="color: #ffd700; margin-left: 5px; font-size: 14px;">‚≠ê</span>'
          : '';    
        const contentHTML = this.buildMessageContent(msg, isDeleted);    
        div.innerHTML = `
          ${nameHTML}
          ${replyPreviewHTML}
          <span class="msg-text-content">${contentHTML}</span>${starIcon}
          ${reactionsHTML}
          <div class="msg-meta">
  <span class="msg-time">${time}</span> ${checkHTML}
</div>
        `;    
        if (!isDeleted && msg.edited_at) {
          const metaDiv = div.querySelector('.msg-meta');
          if (metaDiv) {
            const editTag = document.createElement('span');
            editTag.className = 'message-edited-tag';
            editTag.textContent = 'editada';
            metaDiv.insertBefore(editTag, metaDiv.firstChild);
          }
        }    
        MessageInteraction.setup(div, msg);    
        return div;
      },  
      buildReplyPreview(msg) {
        if (!msg.reply_to_message_id || !msg.reply_to_message) return '';    
        const replyMsg = msg.reply_to_message;
        return `
          <div class="reply-preview" onclick="scrollToMessage('${msg.reply_to_message_id}')">
            <div class="reply-preview-name">${replyMsg.abv_name || 'Utilizador'}</div>
            <div class="reply-preview-text">${replyMsg.message || ''}</div>
          </div>
        `;
      },  
      buildStatusChecks(msg, isMe, chatRef) {
        if (!isMe) return '';    
        let icon = 'done';
        let checkClass = 'sent';    
        if (chatRef === 'geral') {
          const numLeituras = (msg.chat_message_reads && msg.chat_message_reads[0]) 
            ? msg.chat_message_reads[0].count 
            : 0;
          icon = 'done_all';
          checkClass = (numLeituras >= (AppState.totalTeam - 1) && AppState.totalTeam > 1) 
            ? 'read' 
            : 'delivered';
          const contador = numLeituras > 0 
            ? `<span style="font-size:9px; margin-left:2px; opacity:0.8;">${numLeituras}</span>` 
            : '';
          const msgId = msg.id || 'temp-' + Date.now();
          return `<span id="check-${msgId}" class="material-icons status-checks ${checkClass}">${icon}</span>${contador}`;
        } else {
          const recipientDot = document.querySelector(`.contact[data-nint="${chatRef}"] .status-dot`);
          const isOnline = recipientDot && recipientDot.classList.contains('online');      
          if (msg.read_at) {
            icon = 'done_all';
            checkClass = 'read';
          } else if (isOnline) {
            icon = 'done_all';
            checkClass = 'delivered';
          }      
          const msgId = msg.id || 'temp-' + Date.now();
          return `<span id="check-${msgId}" class="material-icons status-checks ${checkClass}">${icon}</span>`;
        }
      },  
      buildMessageContent(msg, isDeleted) {
        if (isDeleted) {
          return '<span class="deleted-icon">üö´</span> Mensagem apagada';
        }    
        switch(msg.message_type) {
          case 'image':
            let html = `<img src="${msg.file_url}" class="chat-img" data-url="${msg.file_url}" alt="imagem">`;
            if (msg.message) {
              html += `<div class="img-caption">${msg.message}</div>`;
            }
            return html;      
          case 'audio':
            const audioID = `audio-${msg.id || Date.now()}`;
            return `
              <div class="audio-bubble">
                <div class="audio-play-btn" onclick="toggleAudio('${audioID}', this)">
                  <span class="material-icons">play_arrow</span>
                </div>
                <div class="audio-progress-container">
                  <div class="audio-progress-bar">
                    <div id="fill-${audioID}" class="audio-progress-fill"></div>
                  </div>
                  <div class="audio-time" id="time-${audioID}">0:00</div>
                </div>
                <audio id="${audioID}" src="${msg.file_url}" ontimeupdate="updateProgress('${audioID}')" onended="resetAudioIcon('${audioID}')"></audio>
              </div>`;      
          case 'file':
            return `
              <div class="file-msg" style="display:flex; align-items:center; gap:10px; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px;">
                <span class="material-icons">insert_drive_file</span>
                <a href="${msg.file_url}" target="_blank" style="font-size:13px; color:inherit; text-decoration:none; overflow:hidden; text-overflow:ellipsis;">${msg.file_name || 'Documento'}</a>
              </div>`;      
          default:
            return Helpers.escapeHtml(msg.message);
        }
      }
    };
    /* ========================= MESSAGE SENDER ========================== */
    const MessageSender = {
  async send(audioText = null, audioUrl = null) {
    const inputEl = DOM.chatInput();
    const sendBtn = document.getElementById("chat-send-btn");
    const text = audioText || inputEl.value.trim();
    
    if (!text && !audioUrl) return;
    sendBtn.disabled = true;

    // 1. L√ìGICA DE EDI√á√ÉO (O QUE FALTA)
    if (typeof EditManager !== 'undefined' && EditManager.editingMessageId && !audioUrl) {
      try {
        const { error } = await supabaseClient
          .from('chat_messages')
          .update({ 
            message: text,
            edited_at: new Date().toISOString() 
          })
          .eq('id', EditManager.editingMessageId);

        if (error) throw error;

        // Limpa o input ANTES de chamar finish()
        inputEl.value = '';
        
        // Dispara o evento input para atualizar os bot√µes
        inputEl.dispatchEvent(new Event('input', { bubbles: true }));
        
        // Agora sim, fecha a barra de edi√ß√£o
        EditManager.finish();
      } catch (err) {
        console.error("Erro ao editar:", err);
      } finally {
        sendBtn.disabled = false;
      }
      return; // Importante: sai da fun√ß√£o para n√£o executar o insert abaixo
    }

    // 2. L√ìGICA DE RESPOSTA (J√Å EXISTENTE)
    if (!audioUrl) {
      inputEl.value = "";
      LayoutManager.resetLayout();
      inputEl.dispatchEvent(new Event('input'));
    }

    // 3. L√ìGICA DE NOVA MENSAGEM (O SEU INSERT ATUAL)
    const currentCorp = Helpers.getCorpNr();
    const senderName = await UserManager.fetchName();
    const messageData = {
        n_int: AppState.currentUserNint, 
        recipient_nint: AppState.currentChat, 
        corp_oper_nr: currentCorp, 
        abv_name: senderName, 
        message: text, 
        file_url: audioUrl, 
        message_type: audioUrl ? 'audio' : 'text'
    };

    if (AppState.currentReplyToMessage) {
      messageData.reply_to_message_id = AppState.currentReplyToMessage.id;
    }

    const { error } = await supabaseClient.from('chat_messages').insert([messageData]);
    
    if (AppState.currentReplyToMessage) {
        ReplyManager.cancel();
    }

    sendBtn.disabled = false;
  }
};
    /* ========================== READ MANAGER =========================== */
    const ReadManager = {
      async markGeralAsRead() {
        const currentCorp = Helpers.getCorpNr();    
        const { data: messages } = await supabaseClient
          .from('chat_messages')
          .select('id')
          .eq('recipient_nint', 'geral')
          .eq('corp_oper_nr', currentCorp)
          .neq('n_int', AppState.currentUserNint);    
        if (!messages || messages.length === 0) return;    
        const { data: alreadyRead } = await supabaseClient
          .from('chat_message_reads')
          .select('message_id')
          .eq('n_int', AppState.currentUserNint);    
        const readIds = new Set(alreadyRead?.map(r => r.message_id) || []);    
        const toInsert = messages
          .filter(m => !readIds.has(m.id))
          .map(m => ({
            message_id: m.id,
            n_int: AppState.currentUserNint,
            read_at: new Date().toISOString(),
            corp_oper_nr: currentCorp
          }));    
        if (toInsert.length === 0) return;    
        const { error } = await supabaseClient
          .from('chat_message_reads')
          .insert(toInsert);    
        if (error) {
          console.error("Erro na leitura:", error);
        } else {
          BadgeManager.update();
        }
      },  
      async sendReceipt(toNint) {
        if (toNint === 'geral' || !toNint) return;    
        const currentCorp = Helpers.getCorpNr();    
        const { error } = await supabaseClient
          .from('chat_messages')
          .update({read_at: new Date().toISOString()})
          .eq('n_int', toNint)
          .eq('recipient_nint', AppState.currentUserNint)
          .eq('corp_oper_nr', currentCorp)
          .is('read_at', null);    
        if (!error && window.readReceiptChannel) {
          window.readReceiptChannel.send({
            type: 'broadcast',
            event: 'read',
            payload: {readerNint: String(AppState.currentUserNint)}
          });
        }
      }
    };
    /* ======================== REACTION MANAGER ========================= */
    const ReactionManager = {
  render(reactions, messageId) {
    if (!reactions || Object.keys(reactions).length === 0) return '';    
    const grouped = {};
    for (const [nint, emoji] of Object.entries(reactions)) {
      if (!grouped[emoji]) grouped[emoji] = [];
      grouped[emoji].push(nint);
    }    
    let html = '<div class="message-reactions">';
    for (const [emoji, users] of Object.entries(grouped)) {
      const count = users.length;
      const isMyReaction = users.includes(AppState.currentUserNint);
      const myClass = isMyReaction ? 'my-reaction' : '';
      const isThumb = emoji === 'üëç' || emoji === 'üëé';
      const thumbClass = isThumb ? 'thumb-emoji' : '';
      const countHTML = count > 1 ? `<span class="reaction-count">${count}</span>` : '';      
      html += `
        <div class="reaction-badge ${myClass}" onclick="event.stopPropagation(); ReactionManager.toggle('${messageId}', '${emoji}')">
          <span class="reaction-emoji ${thumbClass}">${emoji}</span>
          ${countHTML}
        </div>
      `;
    }
    html += '</div>';
    return html;
  },  
  async toggle(messageId, emoji) {
    const { data: msg, error: fetchError } = await supabaseClient
      .from('chat_messages')
      .select('reactions')
      .eq('id', messageId)
      .single();    
    if (fetchError) {
      console.error("Erro ao ler rea√ß√µes:", fetchError);
      return;
    }    
    let currentReactions = msg.reactions || {};    
    if (!currentReactions[emoji]) {
      currentReactions[emoji] = [];
    }    
    const userIndex = currentReactions[emoji].indexOf(AppState.currentUserNint);    
    if (userIndex === -1) {
      currentReactions[emoji].push(AppState.currentUserNint);
    } else {
      currentReactions[emoji].splice(userIndex, 1);
      if (currentReactions[emoji].length === 0) {
        delete currentReactions[emoji];
      }
    }    
    const { error: updateError } = await supabaseClient
      .from('chat_messages')
      .update({ reactions: currentReactions })
      .eq('id', messageId);    
    if (updateError) {
      console.error("Erro ao atualizar rea√ß√£o:", updateError);
    }
  },  
  async handleClick(emoji) {
    if (!AppState.reactionTargetId) {
      console.warn("Nenhuma mensagem selecionada para reagir.");
      return;
    }    
    const targetId = AppState.reactionTargetId;
    const menu = DOM.reactionMenu();
    if (menu) menu.style.display = 'none';    
    SelectionManager.clear();    
    try {
      const { data: msg, error: fetchError } = await supabaseClient
        .from('chat_messages')
        .select('reactions')
        .eq('id', targetId)
        .single();      
      if (fetchError) {
        console.error("Erro ao ler do Supabase:", fetchError);
        return;
      }      
      let currentReactions = msg.reactions || {};      
      if (currentReactions[AppState.currentUserNint] === emoji) {
        delete currentReactions[AppState.currentUserNint];
      } else {
        currentReactions[AppState.currentUserNint] = emoji;
      }      
      const { error: updateError } = await supabaseClient
        .from('chat_messages')
        .update({ reactions: currentReactions })
        .eq('id', targetId);      
      if (updateError) {
        console.error("Erro ao gravar rea√ß√£o:", updateError);
      }
    } catch (err) {
      console.error("Erro inesperado:", err);
    }
  },  
  openFullPicker() {
    const menu = DOM.reactionMenu();
    const pickerContainer = DOM.emojiContainer();
    const picker = pickerContainer.querySelector('emoji-picker');    
    if (menu) menu.style.display = 'none';
    pickerContainer.style.display = 'block';
    
    // Marca que estamos em modo de rea√ß√£o (n√£o escrever no input)
    pickerContainer.dataset.mode = 'reaction';
    
    if (!picker.dataset.reactionListenerSet) {
      picker.addEventListener('emoji-click', event => {
        // Verifica se estamos em modo de rea√ß√£o
        if (pickerContainer.dataset.mode === 'reaction') {
          event.stopPropagation(); // Impede que outros listeners sejam ativados
          this.handleClick(event.detail.unicode);
          pickerContainer.style.display = 'none';
          delete pickerContainer.dataset.mode; // Limpa o modo
        }
      });
      picker.dataset.reactionListenerSet = "true";
    }
  }
};
    /* ======================== SELECTION MANAGER ======================== */
    const SelectionManager = {
      toggle(messageElement, messageData) {
        const messageId = messageData.id;
        const index = AppState.selectedMessages.findIndex(m => m.id === messageId);    
        if (index > -1) {
          AppState.selectedMessages.splice(index, 1);
          messageElement.classList.remove('selected');
        } else {
          AppState.selectedMessages.push(messageData);
          messageElement.classList.add('selected');
        }    
        const menu = DOM.reactionMenu();
        if (menu && AppState.selectedMessages.length !== 1) {
          menu.style.display = 'none';
        }    
        ActionBar.update();
      },  
      clear() {
  AppState.selectedMessages = [];
  
  // Limpa TODAS as classes de estado que o Long Press pode ter deixado
  document.querySelectorAll('.message').forEach(el => {
    el.classList.remove('selected', 'pressing', 'pressed', 'long-press-active');
    // Remove qualquer overlay de sele√ß√£o que possa existir
  });

  const actionBar = DOM.actionBar();
  if (actionBar) actionBar.classList.remove('show');

  const menu = DOM.reactionMenu();
  if (menu) {
    menu.style.display = 'none';
    menu.classList.remove('show');
  }

  // RESET de vari√°veis de controle de toque
  AppState.reactionTargetId = null;
  AppState.isLongPressing = false; // Se usar esta vari√°vel no EventListener
  
  // Limpa sele√ß√µes de texto do sistema (o azul do navegador)
  if (window.getSelection) { window.getSelection().removeAllRanges(); }
}
    };
    /* =========================== ACTION BAR ============================ */
    const ActionBar = {
      update() {
        const actionBar = DOM.actionBar();
        const counter = document.getElementById('action-counter');
        const replyBtn = document.getElementById('action-reply');
        const copyBtn = document.getElementById('action-copy');
        const editBtn = document.getElementById('action-edit');
        const deleteBtn = document.getElementById('action-delete');
        const starBtn = document.getElementById('action-star');
        const menu = DOM.reactionMenu();    
        const count = AppState.selectedMessages.length;    
        if (count === 0) {
          actionBar.classList.remove('show');
          if (menu) menu.style.display = 'none';
          return;
        }    
        actionBar.classList.add('show');    
        if (count > 1 && menu) {
          menu.style.display = 'none';
        }    
        counter.textContent = count === 1 ? '1' : `${count}`;    
        const isOne = count === 1;
        const firstMsg = AppState.selectedMessages[0];
        const allMine = AppState.selectedMessages.every(m => String(m.n_int) === AppState.currentUserNint);
        if (isOne) {
          replyBtn.classList.remove('disabled');
        } else {
          replyBtn.classList.add('disabled');
        }
        if (isOne) {
          copyBtn.classList.remove('disabled');
        } else {
          copyBtn.classList.add('disabled');
        }
        if (isOne && String(firstMsg.n_int) === AppState.currentUserNint) {
          editBtn.classList.remove('disabled');
        } else {
          editBtn.classList.add('disabled');
        }
        if (allMine) {
          deleteBtn.classList.remove('disabled');
        } else {
          deleteBtn.classList.add('disabled');
        }
        if (starBtn && count > 0) {
          const allStarred = AppState.selectedMessages.every(m => 
            m.starred_by && m.starred_by.includes(AppState.currentUserNint)
          );      
          const starIcon = starBtn.querySelector('.material-icons');
          if (starIcon) {
            starIcon.textContent = allStarred ? 'star' : 'star_border';
          }
        }
      }
    };
    /* ========================= MESSAGE ACTIONS ========================= */
    const MessageActions = {
      reply() {
        if (AppState.selectedMessages.length !== 1) return;
        const msg = AppState.selectedMessages[0];
        ReplyManager.set(msg.id, msg.abv_name, msg.message);
        SelectionManager.clear();
      },  
      async star() {
        if (AppState.selectedMessages.length === 0) return;    
        const currentCorp = Helpers.getCorpNr();    
        try {
          for (const msg of AppState.selectedMessages) {
            const { data: msgData, error: fetchError } = await supabaseClient
              .from('chat_messages')
              .select('starred_by')
              .eq('id', msg.id)
              .single();        
            if (fetchError) {
              console.error("Erro ao buscar favoritos:", fetchError);
              continue;
            }        
            let starredBy = msgData?.starred_by || [];
            const index = starredBy.indexOf(AppState.currentUserNint);        
            if (index > -1) {
              starredBy.splice(index, 1);
            } else {
              starredBy.push(AppState.currentUserNint);
            }        
            const { error: updateError } = await supabaseClient
              .from('chat_messages')
              .update({ starred_by: starredBy })
              .eq('id', msg.id)
              .eq('corp_oper_nr', currentCorp);        
            if (updateError) {
              console.error("Erro ao atualizar favorito:", updateError);
            }        
            const msgIndex = AppState.selectedMessages.findIndex(m => m.id === msg.id);
            if (msgIndex > -1) {
              AppState.selectedMessages[msgIndex].starred_by = starredBy;
            }
          }      
          ActionBar.update();
          setTimeout(() => SelectionManager.clear(), 300);
        } catch (error) {
          console.error("Erro inesperado em actionStar:", error);
        }
      },  
      copy() {
        if (AppState.selectedMessages.length !== 1) return;
        const msg = AppState.selectedMessages[0];    
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(msg.message).then(() => {
            alert('‚úÖ Texto copiado!');
          }).catch(() => {
            this.fallbackCopy(msg.message);
          });
        } else {
          this.fallbackCopy(msg.message);
        }    
        SelectionManager.clear();
      },  
      fallbackCopy(text) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();    
        try {
          document.execCommand('copy');
          alert('‚úÖ Texto copiado!');
        } catch (err) {
          alert('‚ùå Erro ao copiar texto');
        }    
        document.body.removeChild(textArea);
      },  
      forward() {
        if (AppState.selectedMessages.length === 0) return;    
        AppState.messagesToForward = AppState.selectedMessages.map(msg => ({
          message_type: msg.message_type || 'text',
          message: msg.message || '',
          file_url: msg.file_url || null,
          file_name: msg.file_name || null
        }));    
        SelectionManager.clear();    
        const messagesEl = DOM.messages();
        const contactListEl = DOM.contactList();
        const contactTitle = DOM.contactTitle();
        const backBtn = DOM.backHeader();
        const inputBar = DOM.inputBar();
        const chatIdInfo = DOM.chatIdInfo();    
        if (window.innerWidth <= 768) {
          messagesEl.style.display = 'none';
          contactListEl.style.display = 'block';
          contactTitle.style.display = 'block';
          backBtn.style.display = 'none';
          inputBar.style.display = 'none';
          chatIdInfo.style.display = 'none';
        }
      },  
      async delete() {
        if (!AppState.selectedMessages || AppState.selectedMessages.length === 0) return;    
        const allMine = AppState.selectedMessages.every(m => String(m.n_int) === AppState.currentUserNint);
        const choice = await this.askConfirm(AppState.selectedMessages.length, allMine);    
        if (choice === 'cancel') return;    
        for (const msg of AppState.selectedMessages) {
          if (choice === 'todos') {
            if (String(msg.n_int) === AppState.currentUserNint) {
              await supabaseClient
                .from('chat_messages')
                .update({ 
                  deleted_at: new Date().toISOString(),
                  message: 'Mensagem apagada'
                })
                .eq('id', msg.id);
            }
          } else if (choice === 'mim') {
            const msgElement = Helpers.getMessageElement(msg.id);
            if (msgElement) msgElement.style.display = 'none';
          }
        }    
        SelectionManager.clear();
      },  
      askConfirm(count, allMine) {
        const modal = document.getElementById('modal-confirm');
        if (modal) {
          const textElement = modal.querySelector('.confirm-text');
          if (textElement) {
            textElement.innerText = count === 1 ? 'Elimininar mensagem?' : `Elimininar ${count} mensagens?`;
          }      
          const btnTodos = modal.querySelector('.btn-confirm-action');
          if (btnTodos) {
            btnTodos.style.display = allMine ? 'block' : 'none';
          }      
          modal.style.display = 'flex';
        }    
        return new Promise(resolve => {
          AppState.confirmResolver = resolve;
        });
      },  
      confirmResponse(choice) {
        const modal = document.getElementById('modal-confirm');
        if (modal) modal.style.display = 'none';
        
        if (AppState.confirmResolver) {
          AppState.confirmResolver(choice);
          AppState.confirmResolver = null;
        }
      },  
      edit() {
    if (AppState.selectedMessages.length !== 1) return;
    const msg = AppState.selectedMessages[0];
    
    // 1. Verifica√ß√µes de seguran√ßa
    if (String(msg.n_int) !== AppState.currentUserNint || msg.deleted_at) return;

    // 2. Chamar o Manager (Garante que o ID fica guardado no s√≠tio certo)
    if (typeof EditManager !== 'undefined') {
        EditManager.start(msg.id, msg.message);
    } else {
        // Fallback caso n√£o queiras usar o objeto EditManager
        this._legacyEdit(msg);
    }
    
    SelectionManager.clear();
}
    };
    /* ========================== REPLY MANAGER ========================== */
    const ReplyManager = {
      set(messageId, senderName, messageText) {
        AppState.currentReplyToMessage = {
          id: messageId,
          name: senderName,
          text: messageText
        };    
        document.getElementById('reply-to-name').textContent = senderName;
        document.getElementById('reply-to-text').textContent = messageText;
        document.getElementById('reply-bar').style.display = 'block';
        DOM.chatInput().focus();
      },  
      cancel() {
        AppState.currentReplyToMessage = null;
        document.getElementById('reply-bar').style.display = 'none';
      }
    };
    /* ========================== EDIT MANAGER =========================== */
    const EditManager = {
  editingMessageId: null,

  start(messageId) {
    const msgElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!msgElement) return;
    
    this.editingMessageId = messageId;
    const textContent = msgElement.querySelector('.msg-text-content').innerText;
    const chatInput = document.getElementById('chat-input');
    
    chatInput.value = textContent;
    chatInput.focus();
    
    const editBar = document.querySelector('.edit-bar');
    editBar.querySelector('.edit-text-preview').textContent = textContent;
    editBar.style.display = 'block';
    
    // Fecha a barra de a√ß√µes (copiar, editar, etc)
    ActionBarManager.close();
    
    // Atualiza os bot√µes (esconde c√¢mara, mostra enviar)
    chatInput.dispatchEvent(new Event('input'));
  },

  cancel() {
    this.editingMessageId = null;
    document.querySelector('.edit-bar').style.display = 'none';
    document.getElementById('chat-input').value = '';
    
    // --- O QUE FALTA AQUI PARA N√ÉO FICAR PRESA ---
    SelectionManager.clear(); // Remove o azul e o estado de presslong
    ChatInputHandler.toggleSendButton(); // Volta a mostrar a c√¢mara instantaneamente
  },

  finish() { 
    this.editingMessageId = null;
    document.querySelector('.edit-bar').style.display = 'none';
    document.getElementById('chat-input').value = '';
    
    // --- O QUE FALTA AQUI PARA N√ÉO FICAR PRESA ---
    SelectionManager.clear(); // Limpa tudo ap√≥s o envio bem-sucedido
    ChatInputHandler.toggleSendButton(); // Garante que a c√¢mara volta se o input estiver vazio
  }
};
    /* ======================= MESSAGE INTERACTION ======================= */
    const MessageInteraction = {
      setup(messageElement, messageData) {
        let pressTimer;
        let isLongPress = false;        
        messageElement.addEventListener('touchstart', (e) => {
          isLongPress = false;
          pressTimer = setTimeout(() => {
            isLongPress = true;
            if (navigator.vibrate) navigator.vibrate(50);            
            const menu = DOM.reactionMenu();
            if (menu) menu.style.display = 'none';            
            SelectionManager.toggle(messageElement, messageData);            
            if (AppState.selectedMessages.length === 1 && menu) {
              this.showReactionMenu(messageElement, messageData.id, menu);
            }
          }, 500);
        }, { passive: true });        
        messageElement.addEventListener('touchend', () => clearTimeout(pressTimer));
        messageElement.addEventListener('touchmove', () => clearTimeout(pressTimer));        
        messageElement.addEventListener('click', (e) => {
          const menu = DOM.reactionMenu();
          if (AppState.selectedMessages.length > 0) {
            e.preventDefault();
            SelectionManager.toggle(messageElement, messageData);
            if (menu) menu.style.display = 'none';
          }
        });
      },      
      showReactionMenu(messageElement, messageId, menu) {
        AppState.reactionTargetId = messageId;
        const scrollContainer = menu.querySelector('.emoji-scroll-container');
        if (scrollContainer) scrollContainer.scrollLeft = 0;        
        menu.style.display = 'flex';        
        const menuWidth = 215;
        const menuHeight = 45;
        const rect = messageElement.getBoundingClientRect();        
        let posX = rect.left + (rect.width / 2) - (menuWidth / 2);
        if (posX < 10) posX = 10;
        if (posX + menuWidth > window.innerWidth) {
          posX = window.innerWidth - menuWidth - 10;
        }        
        let posY = rect.bottom + 10;
        if (posY + menuHeight > window.innerHeight - 60) {
          posY = rect.top - menuHeight - 10;
        }        
        menu.style.left = posX + 'px';
        menu.style.top = posY + 'px';
      }
    };
    /* ========================== AUDIO PLAYER =========================== */
    const AudioPlayer = {
      toggle(id, btn) {
        const audio = document.getElementById(id);
        const icon = btn.querySelector('.material-icons');    
        if (audio.paused) {
          document.querySelectorAll('audio').forEach(a => {
            if (a.id !== id) {
              a.pause();
              const otherBtn = document.querySelector(`[onclick*="${a.id}"] .material-icons`);
              if (otherBtn) otherBtn.textContent = 'play_arrow';
            }
          });      
          audio.play();
          icon.textContent = 'pause';
        } else {
          audio.pause();
          icon.textContent = 'play_arrow';
        }
      },  
      updateProgress(id) {
        const audio = document.getElementById(id);
        const fill = document.getElementById(`fill-${id}`);
        const timeDisplay = document.getElementById(`time-${id}`);    
        if (!audio.duration) return;    
        const percent = (audio.currentTime / audio.duration) * 100;
        fill.style.width = percent + "%";    
        const mins = Math.floor(audio.currentTime / 60);
        const secs = Math.floor(audio.currentTime % 60);
        timeDisplay.textContent = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
      },  
      resetIcon(id) {
        const icon = document.querySelector(`[onclick*="${id}"] .material-icons`);
        if (icon) icon.textContent = 'play_arrow';    
        const fill = document.getElementById(`fill-${id}`);
        if (fill) fill.style.width = "0%";
      }
    };
   /* =================== KEYBOARD HANDLER (PWA FIX) ==================== */
const KeyboardHandler = {
  init() {
    (function () {
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      const THRESH_OPEN  = isIOS ? 80  : 120;
      const THRESH_CLOSE = isIOS ? 40  : 60;
      let keyboardOpen = false;
      let baseInnerHeight = window.innerHeight;
      const body = document.body;
      const mainContent = document.querySelector(".main-content");
      const messages = document.querySelector(".message-container");
      const inputBar = document.querySelector(".chat-input-bar");
      const inputEl = document.getElementById("chat-input");
      const emojiContainer = document.getElementById("full-emoji-picker-container");      
      
      function setKb(px) {
        document.documentElement.style.setProperty("--kb", Math.max(0, Math.round(px)) + "px");
      }      
      
      function isChatVisible() {
        const el = document.getElementById("messages");
        return el && el.style.display !== "none";
      }      
      
      function getKeyboardHeight() {
        if (!window.visualViewport) return 0;
        const vv = window.visualViewport;
        const a = window.innerHeight - vv.height;
        const b = window.innerHeight - vv.height - vv.offsetTop;
        const c = window.innerHeight - vv.height + vv.offsetTop;
        return Math.max(0, a, b, c);
      }      
      
      function onKeyboardOpen(kbHeight) {
        if (!isChatVisible()) return;
        keyboardOpen = true;
        body.classList.add("keyboard-open");
        messages?.classList.add("keyboard-active");
        inputBar?.classList.add("keyboard-active");
        mainContent?.classList.add("keyboard-active");
        setKb(kbHeight);
        if (emojiContainer && emojiContainer.style.display === "block") {
          emojiContainer.style.display = "none";
        }
        ScrollManager.toBottom(); // ‚úÖ CORRIGIDO
        setTimeout(() => ScrollManager.toBottom(), 120); // ‚úÖ CORRIGIDO
      }      
      
      function onKeyboardClose() {
        keyboardOpen = false;
        body.classList.remove("keyboard-open");
        messages?.classList.remove("keyboard-active");
        inputBar?.classList.remove("keyboard-active");
        mainContent?.classList.remove("keyboard-active");
        setKb(0);
      }      
      
      function detectKeyboard() {
        if (!keyboardOpen) baseInnerHeight = window.innerHeight;
        const kb = getKeyboardHeight();
        if (!keyboardOpen && kb > THRESH_OPEN) {
          onKeyboardOpen(kb);
        } else if (keyboardOpen && kb < THRESH_CLOSE) {
          onKeyboardClose();
        } else if (keyboardOpen) {
          setKb(kb);
          ScrollManager.toBottom(); // ‚úÖ CORRIGIDO
          setTimeout(() => ScrollManager.toBottom(), 120); // ‚úÖ CORRIGIDO
        }
      }      
      
      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", detectKeyboard);
        window.visualViewport.addEventListener("scroll", detectKeyboard);
      } else {
        window.addEventListener("resize", detectKeyboard);
      }      
      
      inputEl?.addEventListener("focus", () => {
        ScrollManager.toBottom(); // ‚úÖ CORRIGIDO
        setTimeout(() => ScrollManager.toBottom(), 120); // ‚úÖ CORRIGIDO
      });      
      
      inputEl?.addEventListener("blur", () => setTimeout(detectKeyboard, 150));      
      
      window.addEventListener("orientationchange", () => {
        setTimeout(() => {
          baseInnerHeight = window.innerHeight;
          detectKeyboard();
        }, 300);
      });      
      
      const messagesEl = document.getElementById("messages");
      if (messagesEl) {
        const obs = new MutationObserver(() => {
          if (!isChatVisible()) onKeyboardClose();
        });
        obs.observe(messagesEl, {attributes: true, attributeFilter: ["style"]});
      }      
      
      body.addEventListener('touchmove', function(e) {
        if (keyboardOpen && body.classList.contains('keyboard-open')) {
          e.preventDefault();
        }
      }, {passive: false});      
    })();
  }
};
    /* ======================== REALTIME MANAGER ========================= */
    const RealtimeManager = {
      init() {
        const currentCorp = Helpers.getCorpNr();
        supabaseClient.channel('chat_realtime')
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'chat_messages',
            filter: `corp_oper_nr=eq.${currentCorp}`
          }, async (payload) => {
            await this.handleNewMessage(payload.new);
          })
          .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'chat_messages',
            filter: `corp_oper_nr=eq.${currentCorp}`
          }, (payload) => {
            this.handleMessageUpdate(payload.new);
          })
          .subscribe();
        supabaseClient.channel('reads_realtime')
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'chat_message_reads',
            filter: `corp_oper_nr=eq.${currentCorp}`
          }, () => {
            BadgeManager.update();
          })
          .subscribe();
        const readReceiptChannel = supabaseClient.channel('read-receipts');
        readReceiptChannel.on('broadcast', {event: 'read'}, (payload) => {
          if (String(payload.payload.readerNint) === AppState.currentChat) {
            document.querySelectorAll('.status-checks').forEach(check => {
              if (!check.classList.contains('read')) {
                check.classList.remove('sent', 'delivered');
                check.classList.add('read');
                check.textContent = 'done_all';
              }
            });
          }
        }).subscribe();    
        window.readReceiptChannel = readReceiptChannel;
        const typingChannel = supabaseClient.channel('typing-status', {
          config: {broadcast: {ack: true, self: false}}
        });    
        typingChannel.on('broadcast', {event: 'typing'}, (payload) => {
          const data = payload.payload;
          if (AppState.currentChat !== 'geral' && String(data.nint) === AppState.currentChat) {
            const statusEl = DOM.typingStatus();
            statusEl.textContent = `${AppState.currentChatName} est√° a escrever...`;
            statusEl.style.display = data.isTyping ? 'block' : 'none';
            if (data.isTyping) ScrollManager.toBottom();
          }
        }).subscribe();
        let typingTimer;
        const inputEl = DOM.chatInput();
        inputEl.addEventListener('input', () => {
          if (AppState.currentChat === 'geral') return;      
          typingChannel.send({
            type: 'broadcast',
            event: 'typing',
            payload: {nint: String(AppState.currentUserNint), isTyping: true}
          });      
          clearTimeout(typingTimer);
          typingTimer = setTimeout(() => {
            typingChannel.send({
              type: 'broadcast',
              event: 'typing',
              payload: {nint: String(AppState.currentUserNint), isTyping: false}
            });
          }, 2000);
        });
        const presenceChannel = supabaseClient.channel('presence-cb360', {
          config: {presence: {key: String(AppState.currentUserNint)}}
        });    
        presenceChannel.on('presence', {event: 'sync'}, () => {
          const state = presenceChannel.presenceState();      
          document.querySelectorAll('.status-dot').forEach(dot => dot.classList.remove('online'));      
          Object.keys(state).forEach((nint) => {
            const dot = document.querySelector(`.contact[data-nint="${nint}"] .status-dot`);
            if (dot) dot.classList.add('online');        
            if (AppState.currentChat !== 'geral' && String(nint) === AppState.currentChat) {
              document.querySelectorAll('.status-checks.sent').forEach(check => {
                check.classList.remove('sent');
                check.classList.add('delivered');
                check.textContent = 'done_all';
              });
            }
          });
        }).subscribe(async (status) => {
          if (status === 'SUBSCRIBED') {
            await presenceChannel.track({
              online_at: new Date().toISOString(),
              nint: String(AppState.currentUserNint)
            });
          }
        });
      },  
      async handleNewMessage(msg) {
        if (msg.reply_to_message_id) {
          const { data: replyData } = await supabaseClient
            .from('chat_messages')
            .select('id, message, abv_name')
            .eq('id', msg.reply_to_message_id)
            .single();      
          if (replyData) {
            msg.reply_to_message = replyData;
          }
        }    
        const involved = [msg.n_int, msg.recipient_nint].map(String);    
        if (AppState.currentChat === 'geral' && msg.recipient_nint === 'geral') {
          MessageManager.addToDOM(msg, 'geral');      
          if (String(msg.n_int) !== AppState.currentUserNint && DOM.messages()?.style.display !== 'none') {
            const currentCorp = Helpers.getCorpNr();
            const geralContact = document.querySelector('.contact[data-nint="geral"]');
            const currentBadge = geralContact?.querySelector('.unread-badge');
            const badgeValue = currentBadge ? currentBadge.textContent : null;        
            supabaseClient.from('chat_message_reads').insert({
              message_id: msg.id,
              n_int: AppState.currentUserNint,
              read_at: new Date().toISOString(),
              corp_oper_nr: currentCorp
            }).then(() => {
              if (badgeValue && geralContact) {
                setTimeout(() => {
                  let badge = geralContact.querySelector('.unread-badge');
                  if (!badge) {
                    badge = document.createElement('div');
                    badge.className = 'unread-badge';
                    geralContact.appendChild(badge);
                  }
                  badge.textContent = badgeValue;
                }, 100);
              }
            });
          }
        } else if (AppState.currentChat !== 'geral' && involved.includes(AppState.currentUserNint) && involved.includes(AppState.currentChat)) {
          MessageManager.addToDOM(msg, AppState.currentChat);      
          if (String(msg.recipient_nint) === AppState.currentUserNint) {
            setTimeout(() => ReadManager.sendReceipt(AppState.currentChat), 100);
          }
        }    
        if (String(msg.n_int) !== AppState.currentUserNint) {
          BadgeManager.update();
        }
      },  
      handleMessageUpdate(msg) {
  const msgElement = Helpers.getMessageElement(msg.id);
  if (!msgElement) return;

  // helper: limpa sele√ß√£o/estado de UI (presslong / context / editing)
  const clearSelectionUI = () => {
    // 1) remove sele√ß√£o de texto (azul)
    const sel = window.getSelection?.();
    if (sel) sel.removeAllRanges();

    // 2) remove classes/atributos de sele√ß√£o/edi√ß√£o em TODAS as mensagens
    document.querySelectorAll('.message').forEach(m => {
      m.classList.remove(
        'selected',
        'editing',
        'active',
        'highlight',
        'pressing',
        'pressed',
        'context-open',
        'menu-open',
        'is-selected'
      );
      m.removeAttribute('data-selected');
      m.removeAttribute('aria-selected');
    });

    // 3) remove tamb√©m sele√ß√£o interna (caso metas .selected noutros elementos)
    msgElement.querySelectorAll('.selected, .is-selected').forEach(el =>
      el.classList.remove('selected', 'is-selected')
    );

    // 4) fecha/remover menus/overlays comuns
    document
      .querySelectorAll('.context-menu, .message-menu, .message-actions, .msg-actions-bar, .action-sheet, .popover')
      .forEach(el => el.remove());

    // 5) limpa estado global (se existir)
    if (typeof AppState !== 'undefined' && AppState) {
      const keysToNull = [
        'editingMessageId',
        'selectedMessageId',
        'selectedMessage',
        'longPressMessageId',
        'contextMessageId',
        'activeMessageId',
        'menuMessageId'
      ];
      keysToNull.forEach(k => {
        if (k in AppState) AppState[k] = null;
      });

      // caso tenhas booleans tipo "isSelecting"
      if ('isSelecting' in AppState) AppState.isSelecting = false;
      if ('isEditing' in AppState) AppState.isEditing = false;
    }

    // 6) for√ßa fechar handlers que dependem de click fora
    // (muito comum em menus/context no presslong)
    document.body.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
    document.body.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
    document.body.dispatchEvent(new MouseEvent('click', { bubbles: true }));

    // 7) remove foco (evita outline / estado preso)
    if (document.activeElement && typeof document.activeElement.blur === 'function') {
      document.activeElement.blur();
    }
  };

  // 0) DELETE
  if (msg.deleted_at) {
    msgElement.classList.add('deleted');

    const textContent = msgElement.querySelector('.msg-text-content');
    if (textContent) {
      textContent.innerHTML = '<span class="deleted-icon">üö´</span> Mensagem apagada';
    }

    msgElement.querySelector('.message-reactions')?.remove();
    msgElement.querySelector('.star-icon')?.remove();

    clearSelectionUI();
    return;
  }

  // 1) ATUALIZAR HORA
  const timeEl = msgElement.querySelector('.msg-time');
  const t = msg.edited_at || msg.updated_at || msg.created_at;
  if (timeEl && t) {
    timeEl.textContent = Helpers.formatTime(t);
  }

  // 2) MOSTRAR TAG "editada"
  let editTag = msgElement.querySelector('.message-edited-tag');
  if (msg.edited_at) {
    if (!editTag) {
      const metaDiv = msgElement.querySelector('.msg-meta');
      if (metaDiv) {
        editTag = document.createElement('span');
        editTag.className = 'message-edited-tag';
        editTag.textContent = 'editada';
        metaDiv.insertBefore(editTag, metaDiv.firstChild);
      }
    } else {
      editTag.style.display = 'inline';
    }
  } else if (editTag) {
    editTag.style.display = 'none';
  }

  // 3) ATUALIZAR CONTE√öDO
  const textContent = msgElement.querySelector('.msg-text-content');
  if (textContent) {
    if (msg.message_type === 'image' && msg.file_url) {
      let img = textContent.querySelector('img.chat-img');
      if (!img) {
        textContent.innerHTML = MessageManager.buildMessageContent(msg, false);
      } else {
        img.src = msg.file_url;
        img.dataset.url = msg.file_url;
      }

      const caption = textContent.querySelector('.img-caption');
      const newCaption = (msg.message || '').trim();
      if (newCaption) {
        if (caption) caption.textContent = newCaption;
        else textContent.insertAdjacentHTML('beforeend', `<div class="img-caption"></div>`);
        textContent.querySelector('.img-caption').textContent = newCaption;
      } else {
        caption?.remove();
      }
    } else {
      textContent.textContent = msg.message || '';
    }

    // feedback visual
    textContent.style.transition = "background 0.5s";
    textContent.style.backgroundColor = "rgba(255, 235, 59, 0.2)";
    setTimeout(() => (textContent.style.backgroundColor = "transparent"), 1000);
  }

  // 4) REA√á√ïES
  if (msg.reactions !== undefined) {
    msgElement.querySelector('.message-reactions')?.remove();

    const newReactionsHTML = ReactionManager.render(msg.reactions, msg.id);
    const anchor = msgElement.querySelector('.msg-text-content');
    if (newReactionsHTML && anchor) {
      anchor.insertAdjacentHTML('afterend', newReactionsHTML);
    }
  }

  // 5) ESTRELAS
  if (msg.starred_by !== undefined) {
    msgElement.querySelector('.star-icon')?.remove();

    const isStarred = msg.starred_by && msg.starred_by.includes(AppState.currentUserNint);
    if (isStarred) {
      const anchor = msgElement.querySelector('.msg-text-content');
      if (anchor) {
        anchor.insertAdjacentHTML(
          'afterend',
          '<span class="star-icon" style="color: #ffd700; margin-left: 5px; font-size: 14px;">‚≠ê</span>'
        );
      }
    }
  }

  // 6) STATUS DE LEITURA
  if (msg.read_at && String(msg.n_int) === AppState.currentUserNint) {
    const checkEl = document.getElementById(`check-${msg.id}`);
    if (checkEl) {
      checkEl.classList.remove('sent', 'delivered');
      checkEl.classList.add('read');
      checkEl.textContent = 'done_all';
    }
  }

  // ‚úÖ 7) DESSELECIONAR O BUBBLE AP√ìS UPDATE/EDI√á√ÉO
  clearSelectionUI();
}
      };
    /* ========================= EVENT LISTENERS ========================= */
    const EventListeners = {
      init() {
        document.getElementById("chat-send-btn").onclick = () => MessageSender.send();
        DOM.chatInput().onkeydown = e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            MessageSender.send();
          }
        };
        DOM.chatInput().addEventListener('focus', () => {
          if (AppState.currentChat !== 'geral') ReadManager.sendReceipt(AppState.currentChat);
        });
        document.addEventListener('touchstart', (e) => {
          const menu = DOM.reactionMenu();
          if (menu && menu.style.display === 'flex') {
            const clicouNoMenu = menu.contains(e.target);
            const clicouNaMensagem = e.target.closest('.message');
            const clicouNaBarra = e.target.closest('#action-bar');        
            if (clicouNaBarra) {
              menu.style.display = 'none';
              return;
            }        
            if (!clicouNoMenu && !clicouNaMensagem) {
              menu.style.display = 'none';
              SelectionManager.clear();
            }
          }
        }, {passive: true});    
        document.addEventListener('click', (e) => {
          const menu = DOM.reactionMenu();
          const picker = DOM.emojiContainer();
          
          if (menu && !menu.contains(e.target) && !picker.contains(e.target) && AppState.selectedMessages.length === 0) {
            menu.style.display = 'none';
            picker.style.display = 'none';
          }
        });
      }
    };
    /* ======================== GLOBAL FUNCTIONS ========================= */
    function goBackToMain() {ChatManager.goBack();}
    function clearSelection() {SelectionManager.clear();}
    function actionReply() {MessageActions.reply();}
    function actionStar() {MessageActions.star();}
    function actionCopy() {MessageActions.copy();}
    function actionForward() {MessageActions.forward();}
    function actionDelete() {MessageActions.delete();}
    function actionEdit() {MessageActions.edit();}
    function resConfirm(choice) {MessageActions.confirmResponse(choice);}
    function cancelReply() {ReplyManager.cancel();}
    function cancelEdit() {EditManager.cancel();}
    function scrollToMessage(messageId) {ScrollManager.toMessage(messageId);}
    function handleReactionClick(emoji) {ReactionManager.handleClick(emoji);}
    function openFullEmojiPicker() {ReactionManager.openFullPicker();}
    function toggleAudio(id, btn) {AudioPlayer.toggle(id, btn);}
    function updateProgress(id) {AudioPlayer.updateProgress(id);}
    function resetAudioIcon(id) {AudioPlayer.resetIcon(id);}
    /* ==================== STARTING THE APPLICATION ===================== */
    document.addEventListener('DOMContentLoaded', async () => {
      await CorpManager.loadInfo();
      ThemeManager.load();
      await ContactManager.load();
      BadgeManager.update();
      ImageHandler.init();
      ChatInputHandler.init();
      TypingIndicator.init();
      AudioRecorder.init();
      CameraHandler.init();
      KeyboardHandler.init();
      EventListeners.init();
      RealtimeManager.init();
    });
  </script>
</body>
</html>













